#!/usr/bin/env python

# This script generates the necessary config files to install the package
# using setuptools, pip and conda.
# For testing pip installation, create a user conda environment and activate it
# with the commands:
# $ CONDA_PKGS_DIRS=~/temp/pkgs conda create --prefix ~/envs/setuptest python=3
# $ conda activate ~/envs/setuptest

# ### Package constants

PACKAGE_NAME = 'pfsspec-{name}'
PACKAGE_PATH = './modules/{name}'
PACKAGE_URL = 'https://github.com/Subaru-PFS-GA/ga_pfsspec_{name}'
PACKAGE_NAMESPACE = 'pfs/ga/pfsspec/{name}'
PACKAGE_ASSETS_FOLDER = '../../assets/build'
PACKAGE_SOURCE_FOLDER = './python'
PACKAGE_COMMAND_PREFIX = 'pfsspec'
PACKAGE_DEPENDENCIES = [
    ['tqdm', '>=4.42.1'],
    ['numpy', '>=1.18.5'],
    ['pandas', '>=1.0.1'],
    ['h5py', '>=2.10.0'],
    ['matplotlib', '>=3.1.3'],
    ['scipy', '>=1.5.3'],
    ['pyyaml', '>=6.0']
]

PACKAGES = {
    'core': {
        'description': 'Core functionality for the PFSSPEC packages.',
        'dependencies': PACKAGE_DEPENDENCIES,
    },
    'survey': {
        'description': 'Survey data IO utilities for the PFSSPEC packages.',
        'dependencies': PACKAGE_DEPENDENCIES,
    },
    'stellar': {
        'description': 'Stellar models and utilities for the PFSSPEC packages.',
        'dependencies': PACKAGE_DEPENDENCIES,
    },
    'sim': {
        'description': 'Spectrum simulation library.',
        'dependencies': PACKAGE_DEPENDENCIES,
    },
    'learn': {
        'description': 'Machine learning utilities.',
        'dependencies': PACKAGE_DEPENDENCIES + [
            ['tensorflow', '==2.4.1'],
        ],
    }
}

# ### End packaga constants

import os
import re
import glob
import shutil
import subprocess
import argparse
import logging
from collections.abc import Iterable

PARSER_COMMAND = 'command'

COMMAND_DISCOVER = 'discover'
COMMAND_CONFIGURE = 'configure'
COMMAND_CLEAN = 'clean'
COMMAND_CONDA_BUILD = 'conda-build'
COMMAND_PIP_INSTALL = 'pip-install'

ARG_NEXT_VERSION = '--next-version'
ARG_BUILD_NUMBER = '--build-number'
ARG_PACKAGE = '--package'
ARG_PACKAGE_FOLDER = '--package-folder'
ARG_OUTPUT_FOLDER = '--output-folder'

ENV_CONDA_PKGS_DIRS = 'CONDA_PKGS_DIRS'

def create_parser():
    """
    Register command-line arguments for the script.

    The commands are:
    - discover: discover and print package information.
    - configure: generate the setup configuration files for the package.
    - clean: remove all files generated by the build process.
    - conda-build: build the conda package using conda
    """

    parser = argparse.ArgumentParser()

    sps = parser.add_subparsers(dest=PARSER_COMMAND, required=True)
    pp = []

    p = sps.add_parser(COMMAND_DISCOVER)
    pp.append(p)

    p = sps.add_parser(COMMAND_CONFIGURE)
    pp.append(p)

    p = sps.add_parser(COMMAND_CLEAN)
    pp.append(p)
    p.add_argument(ARG_PACKAGE_FOLDER, type=str, help='Override package folder.')
    p.add_argument(ARG_OUTPUT_FOLDER, type=str, help='Override output folder.')

    p = sps.add_parser(COMMAND_CONDA_BUILD)
    pp.append(p)
    p.add_argument(ARG_PACKAGE_FOLDER, type=str, help='Override package folder.')
    p.add_argument(ARG_OUTPUT_FOLDER, type=str, help='Override output folder.')

    # Arguments common to all modes
    for p in pp:
        p.add_argument(ARG_PACKAGE, type=str, nargs='*', help='Optional list of packages, default is all.')
        p.add_argument(ARG_NEXT_VERSION, type=str, help='Override next version.')
        p.add_argument(ARG_BUILD_NUMBER, type=int, help='Override build number.')

    return parser

def get_default(default=None):
    """
    Return the first non-None value from a list of values.
    """

    if isinstance(default, str):
        return default
    elif isinstance(default, Iterable):
        for d in default:
            if d is not None:
                return d
        return None
    else:
        return default
    
def arg_name_to_key(name):
    """
    Convert a command-line argument name to a dictionary key.
    """

    return name.replace('-', '_').strip('_')

def is_arg(args, name):
    """
    Return True if the argument is present in the dictionary and is not None.
    """

    key = arg_name_to_key(name)
    return key in args and args[key] is not None

def get_arg(args, name, default=None):
    """
    Return the value of the argument if it is present in the dictionary and is not None.
    If the argument is not present, return the default value.
    """

    key = arg_name_to_key(name)
    return args[key] if key in args and args[key] is not None else get_default(default)

def is_env(key):
    """
    Return True if the environment variable is present.
    """

    return key in os.environ

def get_env(key, default=None):
    """
    Return the value of the environment variable if it is present and is not None.
    If the environment variable is not present, return the default value.
    """

    return os.environ[key] if key in os.environ and os.environ[key] is not None else get_default(default)

def set_env(key, value):
    """
    Set the value of an environment variable.
    """

    os.environ[key] = value

def shell(command):
    """
    Execute a shell command synchronously and return the output.
    """

    logging.info('Executing shell command `{}`'.format(command))
    with os.popen(command) as p:
        return p.read()

def run(command):
    """
    Execute a program asynchronously.
    """

    logging.info('Running command `{}`'.format(command))
    subprocess.run(command.split(' '))

def git_create_tag(tag, message):
    """
    Create a new git tag at the current HEAD of the repo
    """
    shell(f"git tag -a {tag} -m '{message}'")
    

def git_get_current_tag():
    """
    Return the most recent git tag.
    """

    # Tag name is assumed to be vX.X.X
    tag = shell("git describe --abbrev=0 --tags --match 'v*.*.*'").strip()
    
    if tag == '':
        raise RuntimeError('No git tags found.')
    
    return tag

def git_get_commits_since(*version):
    """
    Return the number of commits since the last tag.
    """

    tag = format_tag(*version)
    return int(shell(f"git rev-list {tag}..HEAD --count").strip())

def git_is_dirty():
    """
    Return True if the git repository is dirty, i.e. has uncommitted changes
    to tracked files.
    """

    # NOTE: git status will force stripping notebook outputs so it's not a dry operation

    res = shell("git status --porcelain --untracked-files=no")
    return res != ''

def split_version(tag):
    """
    Split a tag name into a tuple of integers.
    """

    # Tag name is assumed to be vX.X.X, only return X.X.X as a tuple of numbers
    return tuple(int(p) for p in tag[1:].split('.'))

def format_tag(*version):
    """
    Format a tuple of integers as a tag name.
    """

    return 'v' + format_version(*version)

def format_version(*version):
    """
    Format a tuple of integers as a version string.
    """

    return '.'.join([ str(i) for i in version ])

def get_versions(args, unknown_args):
    """
    Return the most recent git tag and the next version number based on the number
    of commits since the last tag which will be the build number.
    """

    tag = git_get_current_tag()
    version = split_version(tag)
    build = git_get_commits_since(*version[:2], 0)
    
    if git_is_dirty():
        build += 1
        logging.info(f'Git repo is dirty, bumping build number by one to {build}.')

    # Override from args
    build = get_arg(args, ARG_BUILD_NUMBER, build)

    # Override from args
    if is_arg(args, ARG_NEXT_VERSION):
        next_version = split_version(get_arg(args, ARG_NEXT_VERSION))
    else:
        next_version = version[:2] + (build,)
    
    logging.info(f'Current version: {tag} (from last git tag)')
    logging.info(f'Next version: {format_tag(*next_version)}')
    logging.info(f'Build number: {build}')

    return tag, next_version, build

def cp(input_file, output_file):
    """
    Copy a file.
    """

    dir = os.path.dirname(output_file)
    if not os.path.isdir(dir):
        mkdir(dir)

    shutil.copy2(input_file, output_file)

def mkdir(dir):
    """
    Create a directory.
    """

    if not os.path.isdir(dir):
        os.makedirs(dir, exist_ok=True)
        logging.info("Created directory `{}`".format(dir))
    else:
        logging.info("Found existing directory `{}`".format(dir))

def chdir(dir):
    """
    Change the current working directory.
    """

    os.chdir(dir)
    logging.info("Changed working directory to `{}`".format(dir))

def rmdir(dir):
    """
    Delete a directory recursively.
    """

    try:
        shutil.rmtree(dir)
        logging.info("Removed directory `{}`".format(dir))
    except:
        logging.info("Failed to remove directory `{}`".format(dir))

def sed(patterns, input_file, output_file):
    """
    Replace patterns in a file and write the result to another file.
    """

    with open(input_file) as f:
        lines = f.read()

    for (p, r) in patterns:
        lines = lines.replace(p, r)

    dir = os.path.dirname(output_file)
    if not os.path.isdir(dir):
        mkdir(dir)

    with open(output_file, 'w') as f:
        f.write(lines)

def format_excludes_cfg(excl):
    """
    Format a list of excluded packages as in a setup.cfg file.
    """

    cfg = ''
    for e in excl:
        cfg += '    {}\n'.format(e)
    return cfg

def format_dependencies(dep, indent=''):
    """
    Format a list of dependencies as in a setup.cfg file.
    """

    cfg = ''
    for d in dep:
        cfg += '{}{}'.format(indent, d[0])
        cfg += ' ' + ','.join(d[1:])
        cfg += '\n'
    return cfg

def format_includes_manifest_in(includes):
    """
    Format a list of included files as in a MANIFEST.in file.    
    """

    return ''.join(f'include {i}\n' for i in includes)

def format_console_scripts_yaml(console_scripts):
    """
    Format a list of console scripts as in a yaml file.
    """

    cmd = ''
    for s in console_scripts:
        cmd += '        - {}\n'.format(s)
    return cmd

def format_console_scripts_cfg(console_scripts):
    """
    Format a list of console scripts as in a setup.cfg file.
    """

    cmd = ''
    for s in console_scripts:
        cmd += '    {}\n'.format(s)
    return cmd

class PackageBuilder():
    """
    Implements a package builder task.

    Variables:
    ----------
    name: str
        The name of the package
    path: str
        The root folder of the package (git repo root)
    url: str
        The URL of the package (github link)
    namespace: str
        The Python namespace of the package
    assets_folder: str
        The assets folder for setup template files
    source_folder: str
        The Python source folder of the package, relative to the path
    command_prefix: str
        The command prefix for console scripts
    dependencies: list
        The list of dependencies for the package
    description: str
        The description of the package
    """

    def __init__(self, *,
                 name=None,
                 path=None,
                 url=None,
                 namespace=None,
                 assets_folder=None,
                 source_folder=None,
                 command_prefix=None,
                 dependencies=None,
                 description=None):
        
        self.name = name
        self.path = path
        self.url = url
        self.namespace = namespace
        self.assets_folder = assets_folder
        self.source_folder = source_folder
        self.command_prefix = command_prefix
        self.dependencies = dependencies
        self.description = description

    def get_excludes(self):
        """
        Generate a list of excluded packages (namespace directories).
        """

        excl = [ 'test' ]

        # Generate a list of excluded packages (namespace directories)
        parts = PACKAGE_NAMESPACE.split('/')[:-1]
        for i in range(len(parts)):
            excl.append('/'.join(parts[:i + 1]))

        return excl

    def find_notebooks(self):
        """
        Return the list of all Jupyter notebooks in the package.
        """

        nbs = []
        for fn in glob.glob(os.path.join(self.source_folder, self.namespace, '**/*.ipynb')):
            nbs.append(os.path.relpath(fn, '.'))
        return nbs

    def find_entrypoints(self):
        """
        Find all command-line entrypoints in the package.
        """

        entrypoints = []
        for fn in glob.glob(os.path.join(self.source_folder, self.namespace, 'scripts/*.py')):
            with open(fn, encoding="utf-8") as f:
                if f.readline().startswith("#!/usr/bin/env python3"):
                    cls = os.path.splitext(os.path.split(fn)[1])[0]
                    cmd = cls.replace('_', '')
                    prefix = self.command_prefix
                    namespace = self.namespace.replace('/', '.')
                    entrypoints.append(f'{prefix}-{cmd} = {namespace}.scripts.{cls}:main')

                    logging.info('Found entrypoint `{}`.'.format(cls))

        if len(entrypoints) == 0:
            logging.info('No command-line entrypoints founds.')

        return entrypoints

    def generate_config(self, version, build):
        """
        Generate the setup configuration files for the package.
        """

        logging.info('Generating setup configuration files.')

        excl = self.get_excludes()
        nbs = self.find_notebooks()
        cmd = self.find_entrypoints()

        patterns = (
            ('%%package_name%%', self.name),
            ('%%package_url%%', self.url),
            ('%%package_description%%', self.description),
            ('%%version%%', format_version(*version)),
            ('%%build%%', str(build)),
            ('%%excludes_cfg%%', format_excludes_cfg(excl)),
            ('%%data_files%%', format_includes_manifest_in(nbs)),
            ('%%requirements_txt%%', format_dependencies(self.dependencies)),
            ('%%requirements_yaml%%', format_dependencies(self.dependencies, indent='        - ')),
            ('%%requirements_cfg%%', format_dependencies(self.dependencies, indent='    ')),
            ('%%console_scripts_yaml%%', format_console_scripts_yaml(cmd)),
            ('%%console_scripts_cfg%%', format_console_scripts_cfg(cmd)),
        )
        
        sed(patterns, 
            os.path.join(self.assets_folder, '_version.py'),
            os.path.join(self.source_folder, self.namespace, '_version.py'))
        logging.info('Generated _version.py')

        sed(patterns,
            os.path.join(self.assets_folder, '_meta.yaml'),
            './recipe/meta.yaml')
        logging.info('Generated meta.yaml')

        cp(os.path.join(self.assets_folder, '_conda_build_config.yaml'),
           './recipe/conda_build_config.yaml')
        logging.info('Copied conda_build_config.yaml')

        sed(patterns,
            os.path.join(self.assets_folder, '_setup.cfg'),
            './setup.cfg')
        logging.info('Generated setup.cfg')

        sed(patterns,
            os.path.join(self.assets_folder, '_setup.py'),
            './setup.py')
        logging.info('Generated setup.py')

        sed(patterns,
            os.path.join(self.assets_folder, '_requirements.txt'),
            './requirements.txt')
        logging.info('Copied requirements.txt')

        sed(patterns,
            os.path.join(self.assets_folder, '_MANIFEST.in'),
            './MANIFEST.in')
        logging.info('Generated MANIFEST.in')

    def discover(self, args, unknown_args):
        logging.info(f'Executing setup command `discover` for package `{self.name}`.')

        get_versions(args, unknown_args)
        self.get_excludes()
        self.find_notebooks()
        self.find_entrypoints()

    def configure(self, args, unknown_args):
        logging.info(f'Executing setup command `configure` for package `{self.name}`.')

        tag, next_version, build = get_versions(args, unknown_args)
        self.generate_config(next_version, build)

    def clean(self, args, unknown_args):
        logging.info(f'Executing setup command `clean` for package {self.name}.')

        pkgs_folder = get_arg(args, ARG_PACKAGE_FOLDER, [get_env(ENV_CONDA_PKGS_DIRS), './build/pkgs'])
        output_folder = get_arg(args, ARG_OUTPUT_FOLDER, f'./build/{PACKAGE_NAME}')

        rmdir(pkgs_folder)
        rmdir(output_folder)
        rmdir('./.eggs')
        rmdir(f'./python/{PACKAGE_NAME.replace("-", "_")}.egg-info')
        rmdir('./build')
        rmdir('./dist')
        rmdir('./temp')
        
    def conda_build(self, args, unknown_args):
        logging.info(f'Executing setup command `conda-build` for package {self.name}.')

        tag, next_version, build = get_versions(args, unknown_args)

        package_folder = get_arg(args, ARG_PACKAGE_FOLDER, [get_env(ENV_CONDA_PKGS_DIRS), './build/pkgs'])
        output_folder = get_arg(args, ARG_OUTPUT_FOLDER, f'./build/{PACKAGE_NAME}')

        self.generate_config(next_version, build)

        mkdir(package_folder)
        mkdir(output_folder)

        set_env(ENV_CONDA_PKGS_DIRS, package_folder)
        cmd = f'conda build {ARG_OUTPUT_FOLDER} {output_folder} ' + ' '.join(unknown_args)
        run(cmd)

def main():
    logging.basicConfig(level=logging.INFO)

    cwd = os.getcwd()

    parser = create_parser()
    args, unknown_args = parser.parse_known_args()
    args = args.__dict__

    # List of packages to process, defaults to all
    packages = get_arg(args, ARG_PACKAGE, [ PACKAGES.keys() ])

    for p in packages:
        pp = PackageBuilder(
            name=PACKAGE_NAME.format(name=p),
            path=PACKAGE_PATH.format(name=p),
            url=PACKAGE_URL.format(name=p),
            namespace=PACKAGE_NAMESPACE.format(name=p),
            assets_folder=PACKAGE_ASSETS_FOLDER,
            source_folder=PACKAGE_SOURCE_FOLDER,
            command_prefix=PACKAGE_COMMAND_PREFIX,
            dependencies=PACKAGES[p]['dependencies'],
            description=PACKAGES[p]['description']
        )

        logging.info(f'Processing package `{pp.name}`.')

        chdir(pp.path)

        if args[PARSER_COMMAND] == COMMAND_DISCOVER:
            pp.discover(args, unknown_args)
        elif args[PARSER_COMMAND] == COMMAND_CONFIGURE:
            pp.configure(args, unknown_args)
        elif args[PARSER_COMMAND] == COMMAND_CLEAN:
            pp.clean(args, unknown_args)
        elif args[PARSER_COMMAND] == COMMAND_CONDA_BUILD:
            pp.conda_build(args, unknown_args)
        elif args[PARSER_COMMAND] == COMMAND_PIP_INSTALL:
            raise NotImplementedError()
        else:
            raise NotImplementedError()
        
        chdir(cwd)

if __name__ == "__main__":
    main()